{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n"
    },
    "@venusprotocol/solidity-utilities/contracts/constants.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\nuint256 constant EXP_SCALE = 1e18;\n\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\nuint256 constant MANTISSA_ONE = EXP_SCALE;\n\n/// @dev The approximate number of seconds per year\nuint256 constant SECONDS_PER_YEAR = 31_536_000;\n"
    },
    "@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { SECONDS_PER_YEAR } from \"./constants.sol\";\n\nabstract contract TimeManagerV8 {\n    /// @notice Stores blocksPerYear if isTimeBased is true else secondsPerYear is stored\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable blocksOrSecondsPerYear;\n\n    /// @notice Acknowledges if a contract is time based or not\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    bool public immutable isTimeBased;\n\n    /// @notice Stores the current block timestamp or block number depending on isTimeBased\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    function() view returns (uint256) private immutable _getCurrentSlot;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n\n    /// @notice Thrown when blocks per year is invalid\n    error InvalidBlocksPerYear();\n\n    /// @notice Thrown when time based but blocks per year is provided\n    error InvalidTimeBasedConfiguration();\n\n    /**\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block\n     * If timeBased is true than blocksPerYear_ param is ignored as blocksOrSecondsPerYear is set to SECONDS_PER_YEAR\n     * @param blocksPerYear_ The number of blocks per year\n     * @custom:error InvalidBlocksPerYear is thrown if blocksPerYear entered is zero and timeBased is false\n     * @custom:error InvalidTimeBasedConfiguration is thrown if blocksPerYear entered is non zero and timeBased is true\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor(bool timeBased_, uint256 blocksPerYear_) {\n        if (!timeBased_ && blocksPerYear_ == 0) {\n            revert InvalidBlocksPerYear();\n        }\n\n        if (timeBased_ && blocksPerYear_ != 0) {\n            revert InvalidTimeBasedConfiguration();\n        }\n\n        isTimeBased = timeBased_;\n        blocksOrSecondsPerYear = timeBased_ ? SECONDS_PER_YEAR : blocksPerYear_;\n        _getCurrentSlot = timeBased_ ? _getBlockTimestamp : _getBlockNumber;\n    }\n\n    /**\n     * @dev Function to simply retrieve block number or block timestamp\n     * @return Current block number or block timestamp\n     */\n    function getBlockNumberOrTimestamp() public view virtual returns (uint256) {\n        return _getCurrentSlot();\n    }\n\n    /**\n     * @dev Returns the current timestamp in seconds\n     * @return The current timestamp\n     */\n    function _getBlockTimestamp() private view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Returns the current block number\n     * @return The current block number\n     */\n    function _getBlockNumber() private view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "contracts/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n    /**\n     * @notice Calculates the current borrow interest rate per slot (block or second)\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param badDebt The amount of badDebt in the market\n     * @return The borrow rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) external view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per slot (block or second)\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @param badDebt The amount of badDebt in the market\n     * @return The supply rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa,\n        uint256 badDebt\n    ) external view virtual returns (uint256);\n\n    /**\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\n     * @return Always true\n     */\n    function isInterestRateModel() external pure virtual returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/JumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { TimeManagerV8 } from \"@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { EXP_SCALE, MANTISSA_ONE } from \"./lib/constants.sol\";\n\n/**\n * @title JumpRateModelV2\n * @author Compound (modified by Dharma Labs, Arr00 and Venus)\n * @notice An interest rate model with a steep increase after a certain utilization threshold called **kink** is reached.\n * The parameters of this interest rate model can be adjusted by the owner. Version 2 modifies Version 1 by enabling updateable parameters\n */\ncontract JumpRateModelV2 is InterestRateModel, TimeManagerV8 {\n    /**\n     * @notice The address of the AccessControlManager contract\n     */\n    IAccessControlManagerV8 public accessControlManager;\n\n    /**\n     * @notice The multiplier of utilization rate per block or second that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate per block or second which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplier per block or second after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlockOrTimestamp,\n        uint256 multiplierPerBlockOrTimestamp,\n        uint256 jumpMultiplierPerBlockOrTimestamp,\n        uint256 kink\n    );\n\n    /**\n     * @notice Thrown when the action is prohibited by AccessControlManager\n     */\n    error Unauthorized(address sender, address calledContract, string methodSignature);\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear_ The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear_ The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param jumpMultiplierPerYear_ The multiplier after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param accessControlManager_ The address of the AccessControlManager contract\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block.\n     * @param blocksPerYear_ The number of blocks per year\n     */\n    constructor(\n        uint256 baseRatePerYear_,\n        uint256 multiplierPerYear_,\n        uint256 jumpMultiplierPerYear_,\n        uint256 kink_,\n        IAccessControlManagerV8 accessControlManager_,\n        bool timeBased_,\n        uint256 blocksPerYear_\n    ) TimeManagerV8(timeBased_, blocksPerYear_) {\n        require(address(accessControlManager_) != address(0), \"invalid ACM address\");\n\n        accessControlManager = accessControlManager_;\n\n        _updateJumpRateModel(baseRatePerYear_, multiplierPerYear_, jumpMultiplierPerYear_, kink_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param jumpMultiplierPerYear The multiplierPerBlockOrTimestamp after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @custom:error Unauthorized if the sender is not allowed to call this function\n     * @custom:access Controlled by AccessControlManager\n     */\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external virtual {\n        string memory signature = \"updateJumpRateModel(uint256,uint256,uint256,uint256)\";\n        bool isAllowedToCall = accessControlManager.isAllowedToCall(msg.sender, signature);\n\n        if (!isAllowedToCall) {\n            revert Unauthorized(msg.sender, address(this), signature);\n        }\n\n        _updateJumpRateModel(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per slot (block or second)\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param badDebt The amount of badDebt in the market\n     * @return The borrow rate percentage per slot (block or second) as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) external view override returns (uint256) {\n        return _getBorrowRate(cash, borrows, reserves, badDebt);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per slot (block or second)\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @param badDebt The amount of badDebt in the market\n     * @return The supply rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa,\n        uint256 badDebt\n    ) public view virtual override returns (uint256) {\n        uint256 oneMinusReserveFactor = MANTISSA_ONE - reserveFactorMantissa;\n        uint256 borrowRate = _getBorrowRate(cash, borrows, reserves, badDebt);\n        uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / EXP_SCALE;\n        uint256 incomeToDistribute = borrows * rateToPool;\n        uint256 supply = cash + borrows + badDebt - reserves;\n        return incomeToDistribute / supply;\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `(borrows + badDebt) / (cash + borrows + badDebt - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @param badDebt The amount of badDebt in the market\n     * @return The utilization rate as a mantissa between [0, MANTISSA_ONE]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows and badDebt\n        if ((borrows + badDebt) == 0) {\n            return 0;\n        }\n\n        uint256 rate = ((borrows + badDebt) * EXP_SCALE) / (cash + borrows + badDebt - reserves);\n\n        if (rate > EXP_SCALE) {\n            rate = EXP_SCALE;\n        }\n\n        return rate;\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param jumpMultiplierPerYear The multiplierPerBlockOrTimestamp after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function _updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) internal {\n        baseRatePerBlock = baseRatePerYear / blocksOrSecondsPerYear;\n        multiplierPerBlock = multiplierPerYear / blocksOrSecondsPerYear;\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksOrSecondsPerYear;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per slot (block or second), with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param badDebt The amount of badDebt in the market\n     * @return The borrow rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function _getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) internal view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves, badDebt);\n        uint256 kink_ = kink;\n\n        if (util <= kink_) {\n            return ((util * multiplierPerBlock) / EXP_SCALE) + baseRatePerBlock;\n        }\n        uint256 normalRate = ((kink_ * multiplierPerBlock) / EXP_SCALE) + baseRatePerBlock;\n        uint256 excessUtil;\n        unchecked {\n            excessUtil = util - kink_;\n        }\n        return ((excessUtil * jumpMultiplierPerBlock) / EXP_SCALE) + normalRate;\n    }\n}\n"
    },
    "contracts/lib/constants.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/// @dev The approximate number of seconds per year\nuint256 constant SECONDS_PER_YEAR = 31_536_000;\n\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\nuint256 constant EXP_SCALE = 1e18;\n\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\nuint256 constant MANTISSA_ONE = EXP_SCALE;\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
